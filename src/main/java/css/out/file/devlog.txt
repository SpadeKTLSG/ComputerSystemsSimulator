//arraycopy(源数组, 源数组起始位置, 目标数组, 目标数组起始位置, 复制长度)

反射完成磁盘和文件树之间的通信 -> 失败, 反射稳定性太差, 导致结构冗余

使用Gzip压缩Sring文本使其符合对应的长度限制 -> 失败, 简直是逆天了, Gzip压缩后导致长度爆炸从3->60, 稳定性差, 导致不可逆伤害. 且云端压缩测试结果仍有50%的目录名字无法取用, 因此作为废案处理.仍然使用限制的文件名来展示

修改逻辑增加映射表, 在硬盘中只能存3个字母/数字, 一个汉字占用2个字节, 一个英文占用1个字节, 一个数字占用1个字节, 一个符号占用1个字节; 因此使用映射表来进行转换, 但是映射表的长度也是有限的, 因此仍然需要限制文件名长度(0-999一共1000种路径组合, 根目录8个文件夹下有8个子目录的话, 一个子目录有8个子文件), 那么映射表中的元素项就是文件夹+文件 = 64 + 8*8*8 = 64 * 9 = 576种. 最后说不定磁盘还会比这个映射表先占满呢
那么文件后缀名也要有一个映射表咯, 毕竟只能要一个字节的话最方便的只能是0-9种 = length = 9映射表

接下来手写TXT操作读写, 尽可能简化开发

关于类型适配, 整数我一律用Integer (不用int基元), 字节一律用byte / bytes[] (不用Byte包装)
为什么呢? 实践下来的结果. Integer操作更方便, Byte与其他的转换很繁琐.

!注意, 在项目中称呼的文件系统有广义和狭义的区别: 广义是我本人负责的文件系统模块, 狭义是文件系统模块中的文件模块(处理Java中的文件对象), 与之相对应的是磁盘模块(处理持久化).

现在采用了三级架构(0级-文件系统/磁盘系统 + 1级-Disk/PathHandle + 2级-block/fileHandle)来管理文件系统, 全部是abstract单文件, 内部static工具类, 写好注释后分拣开来; 全局单例对象FileAPP(包含文件和磁盘模块)按名字访问.
12.23完全重构完毕

根据我写的注释和上下文, 你应该能很快理解各部分的内容, 不详细说了

FAT在Java对象和TXT对象中的状态全都是两个分散的对象, 使用时候需要先拼接成为一整个allFAT, 然后切断分开赋值, 有点麻烦, 但是这样做的好处是可以在TXT中直接修改FAT, 而不用再去修改Java对象, 从而减少了代码量, 也减少了出错的可能性

对于DTO文件创建方式XXX.txt, 创建位置和文件名(扩展名)和文件类型都已经赋值好. (仿照Linux交互, 先让用户输入再在保存的时候传到我后端能不能行, 行就进去了, 不行就报错)

老师的要求,,, 我玩不成了- 指将文件存到多个盘块里... 底层写死咯

但是还有有能完成的功能
(指单单设置磁盘块没有所有者 - 逻辑删除), 因为底部逻辑已经写好了会自动删掉, 现在还是直接在Controller上写Service的逻辑而不考虑Controller的内容罢(开发周期赶不上了)

关于通信: 联调的时候可以设置DTO, 例如FILE对象新建构造方法file(String name), 我后面一起处理

磁盘做完其实文件这边东西就一个简单的JavaTree孩子兄弟树对象, 一晚上就能搞定. 但是后面调试以及联调的工期要挺长.
因为其实有一大部分时间要用来思考怎么作规划, 例如"其他模块通信时候的DTO对象", "磁盘作为暴露对象还是作为文件的下面一层而对外界隐藏?", 又如"这个能不能封装? 传递的参数合不合理?" 这些东西我认为是很有益的思考, 并且也更让我体会到了规划Plan to do的感觉.

两个模块都开发完了, 在上面再封装一层文件管理系统, 这样联调的时候只要处理我的最外层FileManageSyS - App即可, 里面的DiskSyS是底层, FileSyS是上层.

关于回收文件问题: 这里砍了需求, 不去回收空节点了, 直接交给GC... 递归删除带有文件夹的文件夹直接删除首领文件夹, 下面的链子断开后无所谓了...

还有一点, 因为根目录文件夹下的文件夹都是虚拟的, 因此他们不能被和其他的所有文件/文件夹一样进行CRUD操作, 也不能进行正常的DTO传递等, 要为其设置特殊的打包方法 ... 这个是很不好的. 但是为了拟合老师的(不合理的)需求, 我只能这么做了... 也就是加了编码难度嘛, 没什么, 牛马就是来吃草干活的(逃

后面看心情和工期, 可以加一个扫描工具, 看看当前磁盘有没有块问题(事实上没必要, 我认为这样架构的代码有很完善的排错能力, 不会轻易陷入的)

新增文件暂时不写去重判断了, 虽然占用磁盘但是仍然是原来的对象... 嘛, 没有要求这个功能(被拖出去打死

压力测试结果(不断输入相同的文件, 虽然文件树TR会覆盖, 但是磁盘空间还是会占用, 这样甚至减轻了我压测的压力): 最后一个块不会被用上
不知道什么时候加上了磁盘占满就会重建文件树的功能...算了就当特性好了, 不要当BUG

getFreeBlock - FAT 分配空闲盘块重大BUG, 具体见Hdisk

这边修复FATbug花了很长时间, 发现主要原因是删除时候没有释放FAT带来的循环依赖问题, order序列出错

发现系统磁盘被占满后很可能发生不可预知的磁盘全部清空 + TR文件树 + PM路径管理器爆炸问题...因此还是不要搞炸了罢

这边工期太紧了, 感觉这个FAT修补不完了; 没有办法,只能把之前的拿回来用了;
主要是这个getOrder方法太关键了, 当初没有设计好判断异常方法的话, 后面许多部分又调用它的方法, 导致了系统内的强耦合了.
当然, 实际上这个逻辑可以放到删除功能里面去设计...那么在删除时候, 置空当前被删除对象盘块的指针罢. 应该就没事了(虽然不符合要求, 但是从逻辑角度上是合情合理的)

好, 按照上面这个思路修复完了, 但是最后的效果是, 磁盘会尽可能的紧凑(将文件写到"空洞"里面去优先级高), 同时虽然FAT序列很乱, 但是能跑起来, 那他就是好的, 并且解决了循环依赖问题, 也就是说, 他是完美的(大概

时间太紧迫了, 判断一个目录内重名文件就不写了, 默认后来的覆盖之前的即可

无法实现的重大BUG: 文件系统始终是JAVA对象,重启后无法复原. 只能进行转移到回收站, 最后只能通过格式化来实现清理...
很好的模拟了当前系统的特色(啊这

下面基本是联调的事情了,写一下开发记录

1. ?文件的树形结构路径传递
传递pathName -> DTO pathname : 1.去掉第一个"/" 2.合并path和Name(替换冒号为/) 3.带上扩展名(带不上)
