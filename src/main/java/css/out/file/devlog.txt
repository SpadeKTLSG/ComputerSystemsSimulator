//arraycopy(源数组, 源数组起始位置, 目标数组, 目标数组起始位置, 复制长度)

反射完成磁盘和文件树之间的通信 -> 失败, 反射稳定性太差, 导致结构冗余

使用Gzip压缩Sring文本使其符合对应的长度限制 -> 失败, 简直是逆天了, Gzip压缩后导致长度爆炸从3->60, 稳定性差, 导致不可逆伤害. 且云端压缩测试结果仍有50%的目录名字无法取用, 因此作为废案处理.仍然使用限制的文件名来展示

修改逻辑增加映射表, 在硬盘中只能存3个字母/数字, 一个汉字占用2个字节, 一个英文占用1个字节, 一个数字占用1个字节, 一个符号占用1个字节; 因此使用映射表来进行转换, 但是映射表的长度也是有限的, 因此仍然需要限制文件名长度(0-999一共1000种路径组合, 根目录8个文件夹下有8个子目录的话, 一个子目录有8个子文件), 那么映射表中的元素项就是文件夹+文件 = 64 + 8*8*8 = 64 * 9 = 576种. 最后说不定磁盘还会比这个映射表先占满呢
那么文件后缀名也要有一个映射表咯, 毕竟只能要一个字节的话最方便的只能是0-9种 = length = 9映射表

接下来手写TXT操作读写, 尽可能简化开发

关于类型适配, 整数我一律用Integer (不用int基元), 字节一律用byte / bytes[] (不用Byte包装)
为什么呢? 实践下来的结果. Integer操作更方便, Byte与其他的转换很繁琐.

!注意, 在项目中称呼的文件系统有广义和狭义的区别: 广义是我本人负责的文件系统模块, 狭义是文件系统模块中的文件模块(处理Java中的文件对象), 与之相对应的是磁盘模块(处理持久化).

现在采用了三级架构(0级-文件系统/磁盘系统 + 1级-Disk/PathHandle + 2级-block/fileHandle)来管理文件系统, 全部是abstract单文件, 内部static工具类, 写好注释后分拣开来; 全局单例对象FileAPP(包含文件和磁盘模块)按名字访问.
12.23完全重构完毕

根据我写的注释和上下文, 你应该能很快理解各部分的内容, 不详细说了

FAT在Java对象和TXT对象中的状态全都是两个分散的对象, 使用时候需要先拼接成为一整个allFAT, 然后切断分开赋值, 有点麻烦, 但是这样做的好处是可以在TXT中直接修改FAT, 而不用再去修改Java对象, 从而减少了代码量, 也减少了出错的可能性

对于DTO文件创建方式XXX.txt, 创建位置和文件名(扩展名)和文件类型都已经赋值好. (仿照Linux交互, 先让用户输入再在保存的时候传到我后端能不能行, 行就进去了, 不行就报错)

老师的要求,,, 我玩不成了- 指将文件存到多个盘块里... 底层写死咯

但是还有有能完成的功能
(指单单设置磁盘块没有所有者 - 逻辑删除), 因为底部逻辑已经写好了会自动删掉, 现在还是直接在Controller上写Service的逻辑而不考虑Controller的内容罢(开发周期赶不上了)
